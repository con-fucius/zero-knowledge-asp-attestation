// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title IVerifier Interface
 * @notice Defines the function signature for the ZK-SNARK Verifier contract.
 * @dev This interface matches the Verifier contract generated by SnarkJS (Groth16).
 *      The actual Verifier contract code will be generated during the ZK setup.
 */
interface IVerifier {
    /**
     * @notice Verifies a Groth16 ZK-SNARK proof.
     * @param a The proof component 'a'.
     * @param b The proof component 'b'.
     * @param c The proof component 'c'.
     * @param input The public inputs used to generate the proof. For our circuit,
     *              this will contain [root]. knownBadLeafHash is implicitly checked
     *              within the circuit logic against the private leaf input for this demo.
     * @return r True if the proof is valid for the given public inputs, false otherwise.
     */
    function verifyProof(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[1] memory input // Public inputs array
    ) external view returns (bool r);
}

/**
 * @title ASPRegistry Contract
 * @notice Manages registration of Association Set Providers (ASPs) and stores
 *         their verified exclusion set attestations.
 * @dev Uses a ZK Verifier contract to validate proofs submitted by ASPs.
 */
contract ASPRegistry {
    // --- State Variables ---

    /**
     * @notice Stores information about a single attestation submitted by an ASP.
     */
    struct Attestation {
        uint256 root;      // Merkle Root commitment of the ASP's exclusion set at this time.
        uint256 timestamp; // Timestamp when the attestation was successfully verified and stored.
        bool isValid;      // Flag indicating if the associated ZK proof was valid.
                           // We only store valid ones in the main history, but this could be adapted.
    }

    address public owner; // Address of the contract deployer/administrator.
    IVerifier public immutable verifier; // Immutable address of the deployed Verifier contract.

    mapping(address => bool) public registeredASPs; // Mapping to track registered ASP addresses.
    mapping(address => Attestation[]) public attestations; // Mapping from ASP address to their history of valid attestations.

    // --- Events ---

    event ASPRegistered(address indexed asp);
    event ASPDeregistered(address indexed asp);
    event AttestationSubmitted(
        address indexed asp,
        uint256 root,
        uint256 timestamp,
        bool isValid // Indicates if the submitted proof verified successfully
    );

    // --- Modifiers ---

    /**
     * @dev Restricts function access to the contract owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "ASPRegistry: Caller is not the owner");
        _;
    }

    /**
     * @dev Restricts function access to registered ASPs.
     */
    modifier onlyRegisteredASP() {
        require(registeredASPs[msg.sender], "ASPRegistry: Caller is not a registered ASP");
        _;
    }

    // --- Constructor ---

    /**
     * @notice Deploys the contract, setting the owner and the Verifier address.
     * @param _verifierAddress The address of the already deployed ZK Verifier contract.
     */
    constructor(address _verifierAddress) {
        require(_verifierAddress != address(0), "ASPRegistry: Invalid verifier address");
        owner = msg.sender;
        verifier = IVerifier(_verifierAddress);
    }

    // --- Owner Functions ---

    /**
     * @notice Registers a new ASP address, allowing it to submit attestations.
     * @param _asp The address of the ASP to register.
     */
    function registerASP(address _asp) external onlyOwner {
        require(_asp != address(0), "ASPRegistry: Invalid ASP address");
        require(!registeredASPs[_asp], "ASPRegistry: ASP already registered");
        registeredASPs[_asp] = true;
        emit ASPRegistered(_asp);
    }

    /**
     * @notice Deregisters an ASP address, revoking its submission rights.
     * @param _asp The address of the ASP to deregister.
     */
    function deregisterASP(address _asp) external onlyOwner {
        require(registeredASPs[_asp], "ASPRegistry: ASP not registered");
        registeredASPs[_asp] = false;
        emit ASPDeregistered(_asp);
    }

    // --- ASP Functions ---

    /**
     * @notice Allows a registered ASP to submit a new exclusion set commitment (root)
     *         along with its corresponding ZK proof for verification.
     * @param a The ZK proof component 'a'.
     * @param b The ZK proof component 'b'.
     * @param c The ZK proof component 'c'.
     * @param input The public inputs for the proof (expected to be [root]).
     */
    function submitAttestation(
        uint[2] memory a,
        uint[2][2] memory b,
        uint[2] memory c,
        uint[1] memory input // Public inputs: [root]
    ) external onlyRegisteredASP {
        // Extract the submitted root from the public inputs
        uint256 submittedRoot = input[0];

        // Verify the ZK proof using the Verifier contract
        bool isValidProof = verifier.verifyProof(a, b, c, input);

        // Emit event regardless of validity for logging/monitoring purposes
        emit AttestationSubmitted(msg.sender, submittedRoot, block.timestamp, isValidProof);

        // Only store the attestation if the proof is valid
        if (isValidProof) {
            Attestation memory newAttestation = Attestation({
                root: submittedRoot,
                timestamp: block.timestamp,
                isValid: true // Proof verified successfully
            });
            attestations[msg.sender].push(newAttestation);
        } else {
            // Optionally revert if proof is invalid, or just don't store it (as done here).
            // Reverting might be better to signal failure clearly to the ASP.
             revert("ASPRegistry: Invalid ZK proof provided");
        }
    }

    // --- View Functions ---

    /**
     * @notice Retrieves the most recent *valid* attestation for a given ASP.
     * @param _asp The address of the ASP.
     * @return The latest valid Attestation struct. Reverts if no valid attestation exists.
     */
    function getLatestValidAttestation(address _asp) external view returns (Attestation memory) {
        Attestation[] storage aspAttestations = attestations[_asp];
        // Iterate backwards to find the most recent valid one efficiently
        for (uint i = aspAttestations.length; i > 0; i--) {
            // Note: isValid check might be redundant if we only store valid ones,
            // but kept here for clarity or if storage logic changes.
            if (aspAttestations[i - 1].isValid) {
                return aspAttestations[i - 1];
            }
        }
        // Revert if no valid attestation is found for the specified ASP
        revert("ASPRegistry: No valid attestation found for ASP");
    }

    /**
     * @notice Checks if an address is currently registered as an ASP.
     * @param _asp The address to check.
     * @return True if the address is registered, false otherwise.
     */
     function isASPRegistered(address _asp) external view returns (bool) {
        return registeredASPs[_asp];
    }
}