// This script simulates an ASP fetching its latest attestation data
// (root, proof, public signals) from its backend service and submitting
// it to the ASPRegistry smart contract on the blockchain.

const hre = require("hardhat"); // Hardhat Runtime Environment
const axios = require('axios'); // HTTP client to fetch data from ASP service

// --- Configuration ---
// URL of the running ASP backend service API
const ASP_SERVICE_URL = "http://127.0.0.1:8000"; // Default local URL

// ACTION REQUIRED: Replace this placeholder with the actual deployed ASPRegistry contract address
// You get this address after running `npm run deploy:local`
const REGISTRY_ADDRESS = "YOUR_ASP_REGISTRY_CONTRACT_ADDRESS";
// ---

/**
 * @notice Formats the ZK proof components from SnarkJS output into the structure
 *         expected by the Solidity Verifier contract's `verifyProof` function.
 * @param proof The proof object generated by SnarkJS.
 * @returns An array containing the formatted [a, b, c] components as arrays of BigInt strings.
 */
function formatProofForSolidity(proof) {
    // Ensure components exist
    if (!proof || !proof.pi_a || !proof.pi_b || !proof.pi_c) {
        throw new Error("Invalid proof object structure received from SnarkJS.");
    }
    // The Verifier contract expects uint[2], uint[2][2], uint[2]
    // We need to convert the decimal strings from SnarkJS proof to BigInt strings for ethers.js
    return [
        proof.pi_a.slice(0, 2).map(x => BigInt(x).toString()), // a: uint[2]
        [
            // b: uint[2][2]
            proof.pi_b[0].slice(0, 2).map(x => BigInt(x).toString()), // b[0]
            proof.pi_b[1].slice(0, 2).map(x => BigInt(x).toString())  // b[1]
        ],
        proof.pi_c.slice(0, 2).map(x => BigInt(x).toString())  // c: uint[2]
    ];
}

async function main() {
    // --- Pre-check: Ensure Registry Address is Set ---
    if (REGISTRY_ADDRESS === "YOUR_ASP_REGISTRY_CONTRACT_ADDRESS" || !hre.ethers.utils.isAddress(REGISTRY_ADDRESS)) {
        console.error("\n❌ Error: Please replace 'YOUR_ASP_REGISTRY_CONTRACT_ADDRESS' in scripts/submit_attestation.js");
        console.error("   with the actual deployed ASPRegistry contract address obtained after running 'npm run deploy:local'.");
        process.exit(1);
    }

    // --- Fetch Latest Attestation from ASP Service ---
    console.log(`\nFetching latest attestation from ASP service at ${ASP_SERVICE_URL}...`);
    let attestationData;
    try {
        const response = await axios.get(`${ASP_SERVICE_URL}/latest-attestation`);
        attestationData = response.data;
        // Basic validation of received data
        if (!attestationData || typeof attestationData !== 'object' || !attestationData.proof || !attestationData.publicSignals || !attestationData.root) {
             throw new Error("Invalid or incomplete data received from ASP service.");
        }
        console.log(`   Fetched attestation. Root (Hex): ${attestationData.root}`);
        // console.log("   Public Signals (Decimal):", attestationData.publicSignals); // For debugging
        // console.log("   Proof Object:", attestationData.proof); // For debugging
    } catch (error) {
        console.error("❌ Error fetching attestation:", error.response ? `${error.response.status} - ${JSON.stringify(error.response.data)}` : error.message);
        console.error("   Ensure the ASP service (npm run start:asp) is running.");
        process.exit(1);
    }

    // --- Prepare for Contract Interaction ---
    // Get the signer account (defaults to the first account configured in Hardhat)
    // This account simulates the registered ASP submitting the attestation.
    const [aspSigner] = await hre.ethers.getSigners();
    console.log(`\nUsing ASP account: ${aspSigner.address} to submit.`);

    // Get contract instance for the deployed ASPRegistry
    const ASPRegistry = await hre.ethers.getContractFactory("ASPRegistry");
    const aspRegistry = await ASPRegistry.attach(REGISTRY_ADDRESS);
    console.log(`   Attached to ASPRegistry contract at ${REGISTRY_ADDRESS}`);

    // --- Format Proof and Inputs for Solidity ---
    console.log("\nFormatting proof and public inputs for Solidity...");
    let a, b, c, publicInputs;
    try {
        [a, b, c] = formatProofForSolidity(attestationData.proof);

        // The public inputs for our simplified circuit's Verifier contract are just [root_decimal].
        // The publicSignals array from snarkjs contains [root_decimal, knownBadLeafHash_decimal].
        // We only need the first element (root) for the verifyProof call.
        if (!Array.isArray(attestationData.publicSignals) || attestationData.publicSignals.length < 1) {
             throw new Error("Public signals array is invalid or empty.");
        }
        publicInputs = [attestationData.publicSignals[0]]; // Extract the root (as decimal string)
        console.log("   Formatting successful.");
        // console.log("   Formatted Public Inputs:", publicInputs); // For debugging
    } catch (error) {
        console.error("❌ Error formatting proof or public inputs:", error);
        process.exit(1);
    }


    // --- Submit Attestation Transaction ---
    console.log("\nSubmitting attestation transaction to the ASPRegistry contract...");
    try {
        // Connect the signer to the contract instance to send a transaction
        const tx = await aspRegistry.connect(aspSigner).submitAttestation(a, b, c, publicInputs);
        console.log(`   Transaction sent: ${tx.hash}`);
        console.log("   Waiting for transaction confirmation...");

        // Wait for the transaction to be mined and confirmed
        const receipt = await tx.wait();
        console.log(`   Transaction confirmed in block ${receipt.blockNumber}. Gas used: ${receipt.gasUsed.toString()}`);
        console.log("   ✅ Attestation submitted successfully!");

        // --- Optional: Verify On-Chain State ---
        console.log("\nVerifying latest valid attestation stored on-chain...");
        const latest = await aspRegistry.getLatestValidAttestation(aspSigner.address);
        const onChainRootDecimal = latest.root.toString();
        const expectedRootDecimal = publicInputs[0]; // Root submitted

        console.log(`   ASP Address: ${aspSigner.address}`);
        console.log(`   Timestamp: ${latest.timestamp.toString()} (${new Date(latest.timestamp * 1000).toUTCString()})`);
        console.log(`   Is Valid Proof: ${latest.isValid}`);
        console.log(`   Stored Root (Decimal): ${onChainRootDecimal}`);
        if (onChainRootDecimal === expectedRootDecimal) {
            console.log("   ✅ On-chain root matches submitted root.");
        } else {
            console.warn(`   ⚠️ Warning: On-chain root (${onChainRootDecimal}) does not match submitted root (${expectedRootDecimal}).`);
        }

    } catch (error) {
        console.error("❌ Error submitting attestation transaction:", error);
        // Attempt to decode revert reason if available
        if (error.data) {
            try {
                const decodedError = aspRegistry.interface.parseError(error.data);
                console.error(`   Revert Reason: ${decodedError.name}(${decodedError.args})`);
            } catch (decodeError) {
                console.error("   Could not decode revert reason.");
            }
        }
         if (error.message && error.message.includes("Invalid ZK proof provided")) {
             console.error("   Hint: The Verifier contract rejected the proof. Check circuit inputs/logic or proving key.");
         } else if (error.message && error.message.includes("Caller is not a registered ASP")) {
             console.error(`   Hint: Ensure the account ${aspSigner.address} was registered via deploy script or registerASP function.`);
         }
        process.exit(1);
    }
}

// Execute the main function and handle potential errors
main().catch((error) => {
  console.error("❌ Script failed:", error);
  process.exitCode = 1;
});